"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.start = void 0;
const chalk_1 = __importDefault(require("chalk"));
const concurrently_1 = __importDefault(require("concurrently"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const config_1 = require("../../config");
const core_1 = require("../../core");
const env_1 = require("../../core/env");
const ssl_1 = require("../../core/ssl");
let packageInfo = require("../../../package.json");
function registerCommand(program) {
    program
        .command("start [configName|outputLocation|appDevserverUrl]")
        .usage("[configName|outputLocation|appDevserverUrl] [options]")
        .description("start the emulator from a directory or bind to a dev server")
        .option("-a, --app-location <path>", "the folder containing the source code of the front-end application", config_1.DEFAULT_CONFIG.appLocation)
        .option("-i, --api-location <path>", "the folder containing the source code of the API application", config_1.DEFAULT_CONFIG.apiLocation)
        .option("-O, --output-location <path>", "the folder containing the built source of the front-end application", config_1.DEFAULT_CONFIG.outputLocation)
        .option("-D, --app-devserver-url <url>", "connect to the app dev server at this URL instead of using output location", config_1.DEFAULT_CONFIG.appDevserverUrl)
        .option("-is, --api-devserver-url <url>", "connect to the api server at this URL instead of using output location", config_1.DEFAULT_CONFIG.apiDevserverUrl)
        .option("-j, --api-port <apiPort>", "the API server port passed to `func start`", core_1.parsePort, config_1.DEFAULT_CONFIG.apiPort)
        .option("-q, --host <host>", "the host address to use for the CLI dev server", config_1.DEFAULT_CONFIG.host)
        .option("-p, --port <port>", "the port value to use for the CLI dev server", core_1.parsePort, config_1.DEFAULT_CONFIG.port)
        .option("-s, --ssl", "serve the front-end application and API over HTTPS", config_1.DEFAULT_CONFIG.ssl)
        .option("-e, --ssl-cert <sslCertLocation>", "the SSL certificate (.crt) to use when enabling HTTPS", config_1.DEFAULT_CONFIG.sslCert)
        .option("-k, --ssl-key <sslKeyLocation>", "the SSL key (.key) to use when enabling HTTPS", config_1.DEFAULT_CONFIG.sslKey)
        .option("-r, --run <startupScript>", "run a custom shell command or script file at startup", config_1.DEFAULT_CONFIG.run)
        .option("-t, --devserver-timeout <time>", "the time to wait (in seconds) when connecting to a front-end application's dev server or api server", core_1.parseServerTimeout, config_1.DEFAULT_CONFIG.devserverTimeout)
        .option("-w, --swa-config-location <swaConfigLocation>", "the directory where the staticwebapp.config.json file is located", config_1.DEFAULT_CONFIG.swaConfigLocation)
        .option("-o, --open", "open the browser to the dev server", config_1.DEFAULT_CONFIG.open)
        .option("-f, --func-args <funcArgs>", "pass additional arguments to the func start command")
        .action(async (positionalArg, _options, command) => {
        const options = await (0, core_1.configureOptions)(positionalArg, command.optsWithGlobals(), command, "start");
        if (positionalArg && !(0, core_1.matchLoadedConfigName)(positionalArg)) {
            // If it's not the config name, it's either output location or dev server url
            const isUrl = (0, core_1.isHttpUrl)(positionalArg);
            if (isUrl) {
                if ((0, core_1.isUserOption)("appDevserverUrl")) {
                    core_1.logger.error(`swa deploy <appDevserverUrl> cannot be used when --app-devserver-url option is also set.`);
                    core_1.logger.error(`You either have to use the positional argument or option, not both at the same time.`, true);
                }
                options.appDevserverUrl = positionalArg;
            }
            else {
                if ((0, core_1.isUserOption)("outputLocation")) {
                    core_1.logger.error(`swa deploy <outputLocation> cannot be used when --output-location option is also set.`);
                    core_1.logger.error(`You either have to use the positional argument or option, not both at the same time.`, true);
                }
                options.outputLocation = positionalArg;
            }
        }
        console.warn(chalk_1.default.yellow("***********************************************************************"));
        console.warn(chalk_1.default.yellow("* WARNING: This emulator may not match the cloud environment exactly. *"));
        console.warn(chalk_1.default.yellow("* Always deploy and test your app in Azure.                           *"));
        console.warn(chalk_1.default.yellow("***********************************************************************"));
        console.warn();
        await start(options);
    })
        .addHelpText("after", `
Examples:

Serve static content from a specific folder
swa start ./output-folder

Connect to an already running framework development server
swa start http://localhost:3000

Use staticwebapp.config.json file from a specific location
swa start http://localhost:3000 --swa-config-location ./app-source

Serve static content from a folder and run an API from another folder
swa start ./output-folder --api-location ./api

Use a custom command to run framework development server at startup
swa start http://localhost:3000 --run-build "npm start"

Connect both front-end and the API to running development server
swa start http://localhost:3000 --api-location http://localhost:7071
  `);
}
exports.default = registerCommand;
async function start(options) {
    // WARNING:
    // environment variables are populated using values provided by the user to the CLI.
    // Code below doesn't have access to these environment variables which are defined later below.
    // Make sure this code (or code from utils) does't depend on environment variables!
    var _a, _b, _c, _d, _e;
    let { appLocation, apiLocation, outputLocation, appDevserverUrl, apiDevserverUrl, apiPort, devserverTimeout, ssl, sslCert, sslKey, host, port, run, open, funcArgs, swaConfigLocation, verbose, } = options;
    let useApiDevServer = undefined;
    let startupCommand = undefined;
    let resolvedPortNumber = await (0, core_1.isAcceptingTcpConnections)({ host, port });
    if (resolvedPortNumber === 0) {
        core_1.logger.warn(`Port ${port} is already taken!`);
        resolvedPortNumber = await (0, core_1.askNewPort)();
    }
    else {
        core_1.logger.silly(`Port ${port} is available. Use it.`);
    }
    // still no luck or user refused to use a random port
    if (resolvedPortNumber === 0) {
        core_1.logger.error(`Port ${port} is already in use. Use '--port' to specify a different port.`, true);
    }
    // set the new port number in case we picked a new one (see net.isAcceptingTcpConnections())
    core_1.logger.silly(`Resolved port number: ${resolvedPortNumber}`);
    port = resolvedPortNumber;
    // resolve the absolute path to the appLocation
    appLocation = path_1.default.resolve(appLocation);
    if (appDevserverUrl) {
        core_1.logger.silly(`appDevserverUrl provided, we will try connect to dev server at ${outputLocation}`);
        // TODO: properly refactor this after GA to send appDevserverUrl to the server
        outputLocation = appDevserverUrl;
    }
    else {
        core_1.logger.silly(`Resolving outputLocation=${outputLocation} full path...`);
        let resolvedOutputLocation = path_1.default.resolve(appLocation, outputLocation);
        // if folder exists, start the emulator from a specific build folder (outputLocation), relative to appLocation
        if (fs_1.default.existsSync(resolvedOutputLocation)) {
            outputLocation = resolvedOutputLocation;
        }
        // check for build folder (outputLocation) using the absolute location
        else if (!fs_1.default.existsSync(outputLocation)) {
            core_1.logger.error(`The folder "${resolvedOutputLocation}" is not found. Exit.`, true);
            return;
        }
        core_1.logger.silly(`Resolved outputLocation:`);
        core_1.logger.silly(`  ${outputLocation}`);
    }
    if (apiLocation) {
        // resolves to the absolute path of the apiLocation
        let resolvedApiLocation = path_1.default.resolve(apiLocation);
        if (apiDevserverUrl) {
            // TODO: properly refactor this after GA to send apiDevserverUrl to the server
            useApiDevServer = apiDevserverUrl;
            apiLocation = apiDevserverUrl;
        }
        // make sure api folder exists
        else if (fs_1.default.existsSync(resolvedApiLocation)) {
            apiLocation = resolvedApiLocation;
        }
        else {
            core_1.logger.info(`Skipping API because folder "${resolvedApiLocation}" is missing`, "swa");
        }
    }
    let userWorkflowConfig = {
        appLocation,
        outputLocation,
        apiLocation,
    };
    // mix CLI args with the project's build workflow configuration (if any)
    // use any specific workflow config that the user might provide undef ".github/workflows/"
    // Note: CLI args will take precedence over workflow config
    try {
        // TODO: not sure if we should still do this here, as config/user options should override
        // over any options in the workflow config, but it seems to do the opposite here.
        userWorkflowConfig = (0, core_1.readWorkflowFile)({
            userWorkflowConfig,
        });
        core_1.logger.silly(`User workflow config:`);
        core_1.logger.silly(userWorkflowConfig);
    }
    catch (err) {
        core_1.logger.warn(``);
        core_1.logger.warn(`Error reading workflow configuration:`);
        core_1.logger.warn(err.message);
        core_1.logger.warn(`See https://docs.microsoft.com/azure/static-web-apps/build-configuration?tabs=github-actions#build-configuration for more information.`);
    }
    const isApiLocationExistsOnDisk = fs_1.default.existsSync(userWorkflowConfig === null || userWorkflowConfig === void 0 ? void 0 : userWorkflowConfig.apiLocation);
    // handle the API location config
    let serveApiCommand = "echo 'No API found. Skipping'";
    if (useApiDevServer) {
        serveApiCommand = `echo 'using API dev server at ${useApiDevServer}'`;
        // get the API port from the dev server
        apiPort = (_a = (0, core_1.parseUrl)(useApiDevServer)) === null || _a === void 0 ? void 0 : _a.port;
    }
    else {
        if (apiLocation && (userWorkflowConfig === null || userWorkflowConfig === void 0 ? void 0 : userWorkflowConfig.apiLocation)) {
            // check if the func binary is globally available and if not, download it
            const funcBinary = await (0, core_1.getCoreToolsBinary)();
            const nodeMajorVersion = (0, core_1.getNodeMajorVersion)();
            const targetVersion = (0, core_1.detectTargetCoreToolsVersion)(nodeMajorVersion);
            if (!funcBinary) {
                // prettier-ignore
                core_1.logger.error(`\nCould not find or install Azure Functions Core Tools.\n` +
                    `Install Azure Functions Core Tools with:\n\n` +
                    `  npm i -g azure-functions-core-tools@${targetVersion} --unsafe-perm true\n\n` +
                    `See https://aka.ms/functions-core-tools for more information.`, true);
            }
            else {
                if ((0, core_1.isCoreToolsVersionCompatible)(targetVersion, nodeMajorVersion) === false) {
                    core_1.logger.error(`Found Azure Functions Core Tools v${targetVersion} which is incompatible with your current Node.js v${process.versions.node}.`);
                    core_1.logger.error("See https://aka.ms/functions-node-versions for more information.");
                    process.exit(1);
                }
                // serve the api if and only if the user provides a folder via the --api-location flag
                if (isApiLocationExistsOnDisk) {
                    serveApiCommand = `cd "${userWorkflowConfig.apiLocation}" && ${funcBinary} start --cors "*" --port ${apiPort} ${funcArgs !== null && funcArgs !== void 0 ? funcArgs : ""}`;
                }
            }
        }
    }
    if (ssl) {
        if (sslCert === undefined && sslKey === undefined) {
            core_1.logger.warn(`WARNING: Using built-in UNSIGNED certificate. DO NOT USE IN PRODUCTION!`);
            const pemFilepath = await (0, ssl_1.getCertificate)({
                selfSigned: true,
                days: 365,
                commonName: host,
                organization: `Azure Static Web Apps CLI ${packageInfo.version}`,
                organizationUnit: "Azure Engineering",
                emailAddress: `secure@microsoft.com`,
            });
            sslCert = pemFilepath;
            sslKey = pemFilepath;
        }
        else {
            // user provided cert and key, so we'll use them
            sslCert = sslCert && path_1.default.resolve(sslCert);
            sslKey = sslKey && path_1.default.resolve(sslKey);
        }
    }
    if (run) {
        startupCommand = (0, core_1.createStartupScriptCommand)(run, options);
    }
    // resolve the following config to their absolute paths
    // note: the server will perform a search starting from this path
    swaConfigLocation = path_1.default.resolve(swaConfigLocation || (userWorkflowConfig === null || userWorkflowConfig === void 0 ? void 0 : userWorkflowConfig.appLocation) || process.cwd());
    // WARNING: code from above doesn't have access to env vars which are only defined below
    // set env vars for current command
    const envVarsObj = {
        SWA_RUNTIME_CONFIG_LOCATION: swaConfigLocation,
        SWA_RUNTIME_WORKFLOW_LOCATION: (_b = userWorkflowConfig === null || userWorkflowConfig === void 0 ? void 0 : userWorkflowConfig.files) === null || _b === void 0 ? void 0 : _b[0],
        SWA_CLI_DEBUG: verbose,
        SWA_CLI_API_PORT: `${apiPort}`,
        SWA_CLI_APP_LOCATION: userWorkflowConfig === null || userWorkflowConfig === void 0 ? void 0 : userWorkflowConfig.appLocation,
        SWA_CLI_OUTPUT_LOCATION: userWorkflowConfig === null || userWorkflowConfig === void 0 ? void 0 : userWorkflowConfig.outputLocation,
        SWA_CLI_API_LOCATION: userWorkflowConfig === null || userWorkflowConfig === void 0 ? void 0 : userWorkflowConfig.apiLocation,
        SWA_CLI_HOST: `${host}`,
        SWA_CLI_PORT: `${port}`,
        SWA_CLI_APP_SSL: ssl ? "true" : "false",
        SWA_CLI_APP_SSL_CERT: sslCert,
        SWA_CLI_APP_SSL_KEY: sslKey,
        SWA_CLI_STARTUP_COMMAND: startupCommand,
        SWA_CLI_VERSION: packageInfo.version,
        SWA_CLI_SERVER_TIMEOUT: `${devserverTimeout}`,
        SWA_CLI_OPEN_BROWSER: open ? "true" : "false",
    };
    // merge SWA CLI env variables with process.env
    process.env = {
        ...(0, env_1.swaCLIEnv)(envVarsObj),
        // Prevent react-scripts from opening browser
        BROWSER: "none",
    };
    // INFO: from here, code may access SWA CLI env vars.
    const env = (0, env_1.swaCLIEnv)();
    const concurrentlyCommands = [
        // start the reverse proxy
        { command: `node "${path_1.default.join(__dirname, "..", "..", "msha", "server.js")}"`, name: "swa", env, prefixColor: "gray.dim" },
    ];
    if (isApiLocationExistsOnDisk) {
        concurrentlyCommands.push(
        // serve the api, if it's available
        { command: serveApiCommand, name: "api", env, prefixColor: "gray.dim" });
    }
    // run an external script, if it's available
    if (startupCommand) {
        let startupPath = userWorkflowConfig === null || userWorkflowConfig === void 0 ? void 0 : userWorkflowConfig.appLocation;
        concurrentlyCommands.push({ command: `cd "${startupPath}" && ${startupCommand}`, name: "run", env, prefixColor: "gray.dim" });
    }
    core_1.logger.silly(`Starting the SWA emulator with the following configuration:`);
    core_1.logger.silly({
        ssl: [ssl, sslCert, sslKey],
        env: envVarsObj,
        commands: {
            swa: (_c = concurrentlyCommands.find((c) => c.name === "swa")) === null || _c === void 0 ? void 0 : _c.command,
            api: (_d = concurrentlyCommands.find((c) => c.name === "api")) === null || _d === void 0 ? void 0 : _d.command,
            run: (_e = concurrentlyCommands.find((c) => c.name === "run")) === null || _e === void 0 ? void 0 : _e.command,
        },
    });
    const { result } = (0, concurrently_1.default)(concurrentlyCommands, { restartTries: 0, killOthers: ["failure", "success"] });
    await result
        .then((errorEvent) => {
        const killedCommand = errorEvent.filter((event) => event.killed).pop();
        const exitCode = killedCommand === null || killedCommand === void 0 ? void 0 : killedCommand.exitCode;
        core_1.logger.silly(`SWA emulator exited with code ${exitCode}`);
        process.exit();
    }, (errorEvent) => {
        const killedCommand = errorEvent.filter((event) => event.killed).pop();
        const commandName = killedCommand === null || killedCommand === void 0 ? void 0 : killedCommand.command.name;
        const exitCode = killedCommand === null || killedCommand === void 0 ? void 0 : killedCommand.exitCode;
        let commandMessage = ``;
        switch (commandName) {
            case "swa":
                commandMessage = `SWA emulator exited with code ${exitCode}`;
                break;
            case "api":
                commandMessage = `API server exited with code ${exitCode}`;
                break;
            case "run":
                commandMessage = `the --run command exited with code ${exitCode}`;
                break;
        }
        core_1.logger.error(`SWA emulator stoped because ${commandMessage}.`, true);
    })
        .catch((err) => {
        core_1.logger.error(err.message, true);
    });
}
exports.start = start;
//# sourceMappingURL=start.js.map